---
title: "When Setup Scripts Meet Reality: A Tale of TTY and API Keys"
date: 2026-01-30
tags: [api-keys, automation, bash, devops, debugging]
excerpt: "What happens when your perfectly crafted setup script meets the harsh reality of non-interactive environments? A debugging journey through TTY detection and API key configuration."
---

# When Setup Scripts Meet Reality: A Tale of TTY and API Keys

Every developer has been there: you craft what seems like the perfect setup script, test it locally, and everything works beautifully. Then you deploy it to the real world, and suddenly your users are staring at broken installations with no clear explanation. Today, I'm sharing one of those humbling moments from my work on the Letter to Blog blog generation pipeline.

## The Mission: Streamline API Key Configuration

I was working on integrating Anthropic's Claude API into our automated blog generation system. The goal was simple: make the installation process seamless by automatically prompting users for their API key during plugin installation. What could go wrong?

## The Perfect Plan (That Wasn't)

My setup script looked elegant in its simplicity:

```bash
# setup-api-key.sh
if [ -t 0 ]; then
    echo "Setting up Anthropic API key..."
    read -p "Enter your API key: " api_key
    # ... save to config
else
    echo "Non-interactive mode detected, skipping setup"
fi
```

The TTY check (`[ -t 0 ]`) seemed like the right approach—detect if we're running interactively and prompt accordingly. During local testing, everything worked flawlessly.

## Reality Strikes: The Non-Interactive Wall

When users started installing the plugin via `claude plugin install`, something strange happened. The setup hook would run, but users never saw the API key prompt. The script would silently skip the interactive setup, leaving users with a half-configured system.

The culprit? **Plugin installation hooks run in non-interactive mode by default.**

Even though users were running the install command from their terminal, the hook execution environment didn't have a TTY attached. My clever TTY detection was working exactly as designed—it was just detecting the wrong thing.

## The Debugging Journey

Here's what the investigation looked like:

```bash
# Testing the current status
$ python3 blog_gen.py --status
❌ API key not configured

# Checking the config location
$ ls ~/.config/letter-for-my-future-self/
# (directory didn't exist)

# The moment of realization
$ echo "test" | ./scripts/setup-api-key.sh
# Non-interactive mode detected, skipping setup
```

The script was behaving correctly according to its logic, but the user experience was broken. Users had no clear path forward after installation.

## The Fix: Manual Configuration with a Plan

For the immediate problem, I configured the API key manually:

```bash
# Create the config directory
mkdir -p ~/.config/letter-for-my-future-self

# Write the configuration
cat > ~/.config/letter-for-my-future-self/config.json << EOF
{
  "anthropic_api_key": "sk-ant-api03-[YOUR_KEY_HERE]"
}
EOF

# Secure the config file
chmod 600 ~/.config/letter-for-my-future-self/config.json
```

Then verified it worked:

```bash
$ python3 blog_gen.py --status
✅ API key configured (ends with: ...HwAA)
✅ Blog generation ready
```

Success! But this was clearly a band-aid solution.

## Lessons Learned: Better UX for Non-Interactive Installs

This experience highlighted several key insights about building robust installation experiences:

### 1. **Assume Non-Interactive by Default**
Plugin hooks, CI/CD pipelines, and automated deployments often run without TTY access. Design your setup scripts with this as the primary use case, not the exception.

### 2. **Provide Clear Post-Install Instructions**
When interactive setup isn't possible, give users an obvious next step:

```bash
echo "⚠️  API key setup required!"
echo "Run: claude setup api-key"
echo "Or manually edit: ~/.config/letter-for-my-future-self/config.json"
```

### 3. **Offer Multiple Configuration Paths**
Consider supporting:
- Interactive prompts (when possible)
- Environment variables
- Config files
- Command-line flags
- In-session setup commands

### 4. **Test in Real Environments**
Local testing with `./script.sh` doesn't replicate how your script runs in production. Test through the actual installation mechanism your users will encounter.

## The Road Ahead

This debugging session revealed several improvements for the next iteration:

1. **Enhanced setup script** that detects non-interactive mode and provides helpful next steps
2. **In-session configuration** via a `/letter-setup` command for users who need to configure keys later
3. **Better error messaging** that guides users toward successful configuration
4. **Documentation updates** with clear setup instructions for different environments

## Final Thoughts

Sometimes the most educational bugs aren't the complex algorithmic puzzles—they're the simple assumptions that don't hold up in the real world. This TTY detection issue was a good reminder that the gap between "works on my machine" and "works for users" often lies in the environmental details we take for granted.

The next time you're writing a setup script, ask yourself: "What happens when this runs in a Docker container? In a GitHub Action? Through a package manager hook?" Your future self (and your users) will thank you.

---

*Have you encountered similar installation gotchas? Share your debugging war stories—I'd love to hear how you've navigated the gap between development and deployment environments.*